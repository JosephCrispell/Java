package identifyingHomoplasies;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Hashtable;

import geneticDistances.Sequence;
import methods.ArrayMethods;
import methods.CalendarMethods;
import methods.GeneticMethods;
import methods.HashtableMethods;
import phylogeneticTree.BeastNewickTreeMethods;
import phylogeneticTree.CalculateDistancesToMRCAs;
import phylogeneticTree.Node;
import phylogeneticTree.NodeMethods;

public class HomoplasyFinder4 {
	
	public static void main(String[] args) throws IOException{
		
		// Set the path
		String path = "C:/Users/Joseph Crisp/Desktop/UbuntuSharedFolder/Homoplasy/";
								
		// Get the current date
		String date = CalendarMethods.getCurrentDate("dd-MM-yy");
				
		// Set verbose
		boolean verbose = true;
		
		/**
		 * Read in the phylogeny
		 */

		String treeFile = path + "example-AFTER_09-04-18.tree";
		Node tree = readNewickTree(treeFile, verbose);
		
		/**
		 * Read in the FASTA file
		 */
		
		// Read in the FASTA file
		String fasta = path + "example_09-04-18.fasta";
		Sequence[] sequences = GeneticMethods.readFastaFile(fasta, verbose);
		
		// Get the alleles in the population and the isolates they are associated with
		Hashtable<String, ArrayList<String>> alleles = noteAllelesInPopulation(sequences, verbose);
		
		/**
		 * Assign allele to node in phylogeny if:
		 * - Found in all isolates above and not in any below node OR vice versa
		 */
		
		// Assign alleles (CHECK R VERSION - COULD THIS BE WRITTEN FASTA USING ALLELES HASHTABLE ABOVE??)
		assignAllelesToCurrentNode(tree, alleles, sequences.length, verbose);

	}
	
	public static void assignAllelesToCurrentNode(Node node, Hashtable<String, ArrayList<String>> alleles, int nIsolates, boolean verbose){
		
		// Print progress		
		if(verbose == true){
			Global.nodeNo++;
			System.out.println("Assigning alleles to node " + Global.nodeNo + " of " + ((2 * nIsolates) - 1));
		}
		
		// Get all the isolates below the current node and note their common alleles
		String[] idsBelow = getIdsBelowNode(node);
		Hashtable<String, Boolean> allelesBelow = findCommonAlleles(idsBelow, sequences);
		
		// Get all the isolates above the current node and note their common alleles
		String[] idsAbove = ArrayMethods.returnNotCommonElements(idsBelow, ids);
		Hashtable<String, Boolean> allelesAbove = findCommonAlleles(idsAbove, sequences);
		
		// Identify alleles common to isolates above node and NOT in isolates below OR vice versa
		String[] allelesCommonToBelowAndNotInAbove = findAllelesCommonToAAndNotInB(allelesBelow, allelesAbove);
		String[] allelesCommonToAboveAndNotInBelow = findAllelesCommonToAAndNotInB(allelesAbove, allelesBelow);
		String[] allelesToAssignToCurrentNode = ArrayMethods.combine(allelesCommonToBelowAndNotInAbove, allelesCommonToAboveAndNotInBelow);
		
		// Assign each of the alleles found to the current node
		for(String allele : allelesToAssignToCurrentNode){
			if(Global.nodeForEachAllele.get(allele) == null){
				Node[] nodes = {node};
				Global.nodeForEachAllele.put(allele, nodes);
			}else{
				Global.nodeForEachAllele.put(allele, Node.append(Global.nodeForEachAllele.get(allele), node));
				if(verbose == true){
					System.out.println("Current allele (" + allele + ") already assigned to multiple nodes");
				}				
			}			
		}
		
		// Examine each of the current node's sub-nodes
		if(node.getSubNodes().length != 0){
			for(Node subNode : node.getSubNodes()){
			
				assignAllelesToCurrentNode(subNode, alleles, nIsolates, verbose);
			}
		}
	}
	
	public static String[] getIdsBelowNode(Node node){
		
		// Reset the terminal nodes array
		Global.terminalNodes = new Node[0];
					
		// Note the terminal nodes associated with the current node
		noteTerminalNodes(node);
		
		// Note the isolates associated with the terminal nodes found
		String[] ids = new String[Global.terminalNodes.length];
		for(int i = 0; i < Global.terminalNodes.length; i++){
			
			ids[i] = Global.terminalNodes[i].getNodeInfo().getNodeId();
		}
		
		// Reset the terminal nodes array
		Global.terminalNodes = new Node[0];
		
		return(ids);
	}
	
	public static void noteTerminalNodes(Node node){
		
		// Check if we have reached a terminal node
		if(node.getSubNodes().length != 0){
				
			// Examine the subnodes of the current node
			for(Node subNode : node.getSubNodes()){
			
				noteTerminalNodes(subNode);
			}
		}else{
			Global.terminalNodes = NodeMethods.append(Global.terminalNodes, node);
		}
	}

	
	public static Hashtable<String, ArrayList<String>> noteAllelesInPopulation(Sequence[] sequences, boolean verbose){
		
		if(verbose == true){
			System.out.println("Recording alleles present in population...");
		}
		
		// Initialise a hashtable to store the isolates associated with each allele
		Hashtable<String, ArrayList<String>> alleles = new Hashtable<String, ArrayList<String>>();
		
		// Initialise a variable to store each allele
		String allele;
		
		// Examine each isolate
		for(Sequence sequence : sequences){
			
			// Examine each position in the current isolate's sequence
			for(int pos = 0; pos < sequence.getSequence().length; pos++){
				
				// Create a key for the current allele
				allele = pos + ":" + sequence.getSequence()[pos];
				
				// Check if we have encountered the current allele before - note each sequence allele found in
				if(alleles.get(allele) != null){
					ArrayList<String> ids = alleles.get(allele);
					ids.add(sequence.getName());
					alleles.put(allele, ids);
				}else{
					
					ArrayList<String> ids = new ArrayList<String>();
					ids.add(sequence.getName());
					alleles.put(allele, ids);
				}
			}
		}
		
		return alleles;
	}
	
	public static Node readNewickTree(String pathToFile, boolean verbose) throws IOException{
		
		if(verbose == true){
			System.out.println("Reading newick tree file: " + pathToFile + ")...");
		}
		
		// Get the Newick tree string from file
		String newickTree = CalculateDistancesToMRCAs.readNewickFile(pathToFile); 
		
		// Store the tree as a series of traversable nodes
		Node tree = BeastNewickTreeMethods.readNewickNode(newickTree, new Node(null, null, null));
		
		return tree;
	}

}
