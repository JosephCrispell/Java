package identifyingHomoplasies;

import java.io.IOException;
import java.util.Hashtable;

import geneticDistances.Sequence;
import methods.ArrayMethods;
import methods.CalendarMethods;
import methods.GeneticMethods;
import methods.HashtableMethods;
import phylogeneticTree.BeastNewickTreeMethods;
import phylogeneticTree.CalculateDistancesToMRCAs;
import phylogeneticTree.Node;
import phylogeneticTree.NodeMethods;

public class HomoplasyFinder3 {

	public static void main(String[] args) throws IOException{
		
		// Set the path
		String path = "C:/Users/Joseph Crisp/Desktop/UbuntuSharedFolder/Homoplasmy/";
				
		// Get the current date
		String date = CalendarMethods.getCurrentDate("dd-MM-yy");
		
		/**
		 * Read in the phylogeny
		 */

		String treeFile = path + "example_06-03-18.tree";
		Node tree = readNewickTree(treeFile);
		
		/**
		 * Read in the FASTA file
		 */
		
		String fasta = path + "example_06-03-18.fasta";
		Hashtable<String, char[]> sequences = storeSequencesInHashtable(GeneticMethods.readFastaFile(fasta));
		
		/**
		 * Assign alleles to nodes in phylogeny if:
		 * - Found in all isolates above and not in any below or vice versa
		 */
	}
	
	// Methods section
	public static void assignAllelesToCurrentNode(Node node, Hashtable<String, char[]> sequences){
		
		// Get all the isolates below the current node
		String[] idsBelow = getIdsBelowNode(node);
		
		// Note the alleles common to the isolates below the current node
		String[] commonAllelesBelow = findCommonAlleles(idsBelow, sequences);
	}
	
	public static String[] findCommonAlleles(String[] ids, Hashtable<String, char[]> sequences){
		
		// Initialise a hashtable to store the common alleles
		Hashtable<String, Integer> alleleCounts = new Hashtable<String, Integer>();
		
		// Initialise an array to store each isolates sequence
		char[] sequence;
		
		// Initialise a variable to act as an allele key
		String alleleKey;
		
		// Examine each isolate
		for(int idIndex = 0; idIndex < ids.length; idIndex++){
			
			// Get the current isolates sequence
			sequence = sequences.get(ids[idIndex]);
			
			// Examine each site in the current isolates sequence
			for(int pos = 0; pos < sequence.length; pos++){
				
				// Define key based on the current allele at the current position
				alleleKey = pos + ":" + sequence[pos];
				
				// Check whether we have seen the current allele at the current site before
				if(alleleCounts.get(alleleKey) != null){
					alleleCounts.put(alleleKey, alleleCounts.get(alleleKey) + 1);
				}else{
					alleleCounts.put(alleleKey, 1);
				}
			}
		}
		
		// Find the alleles that were found in all the sequences
		String[] commonAlleles = new String[alleleCounts.size()];
		int pos = -1;
		for(String key : HashtableMethods.getKeysString(alleleCounts)){
			
			if(alleleCounts.get(key) == ids.length){
				pos++;
				commonAlleles[pos] = key;
			}
		}
		
		return(ArrayMethods.subset(commonAlleles, 0, pos));
	}
	
	public static void noteTerminalNodes(Node node){
		
		// Check if we have reached a terminal node
		if(node.getSubNodes().length != 0){
				
			// Examine the subnodes of the current node
			for(Node subNode : node.getSubNodes()){
			
				noteTerminalNodes(subNode);
			}
		}else{
			Global.terminalNodes = NodeMethods.append(Global.terminalNodes, node);
		}
	}

	public static String[] getIdsBelowNode(Node node){
				
		// Reset the terminal nodes array
		Global.terminalNodes = new Node[0];
					
		// Note the terminal nodes associated with the current node
		noteTerminalNodes(node);
		
		// Note the isolates associated with the terminal nodes found
		String[] ids = new String[Global.terminalNodes.length];
		for(int i = 0; i < Global.terminalNodes.length; i++){
			
			ids[i] = Global.terminalNodes[i].getNodeInfo().getNodeId();
		}
		
		// Reset the terminal nodes array
		Global.terminalNodes = new Node[0];
		
		return(ids);
	}

	public static Hashtable<String, char[]> storeSequencesInHashtable(Sequence[] sequences){
		
		Hashtable<String, char[]> isolateSequences = new Hashtable<String, char[]>();
		
		// Examine each isolate sequence
		for(int i = 0; i < sequences.length; i++){
			
			isolateSequences.put(sequences[i].getName(), sequences[i].getSequence());
		}
		
		return(isolateSequences);
	}

	public static Node readNewickTree(String pathToFile) throws IOException{
		
		// Get the Newick tree string from file
		String newickTree = CalculateDistancesToMRCAs.readNewickFile(pathToFile); 
		
		// Store the tree as a series of traversable nodes
		Node tree = BeastNewickTreeMethods.readNewickNode(newickTree, new Node(null, null, null));
		
		return tree;
	}

}
