package methods;

import java.io.IOException;

public class SmithWaterman {

	public static void main(String[] args) throws IOException{
		
		char[] a = "GGTTGACTA".toCharArray();
		char[] b = "TGTTACGG".toCharArray();
		
		int match = 3;
		int misMatch = -3;
		int gapPenalty = 2;
		
		int[][] scoringMatrix = new int[a.length + 1][b.length + 1];
		
		printScoringMatrix(scoringMatrix, a, b);
		
		int[][] scoreSources = fillInScoringMatrix(scoringMatrix, a, b, match, misMatch, gapPenalty);
		
		System.out.println("\n\n");
		
		printScoringMatrix(scoringMatrix, a, b);
		
		constructAlignment(scoringMatrix, a, b, scoreSources);
	}
	
	public static void constructAlignment(int[][] scoringMatrix, char[] a, char[] b, int[][] sources){
		
		// Find the max indices
		int[][] maxIndices = findIndicesOfMaximums(scoringMatrix);
		
		// Reconstruct the alignment associated with each maximum found
		for(int pos = 0; pos < maxIndices.length; pos++){
			
			int i = maxIndices[0][pos];
			int j = maxIndices[0][pos];
			
			char[] alignedA = 
			constructAlignment(scoringMatrix, sources, i, j, a, b);
		}
	}
	
	public static void addNextAlignedPair(int[][] scoringMatrix, int[][] sources, int i, int j, char[] a, char[] b, StringBuffer alignedA, StringBuffer alignedB,
			int moveType){
		
		if(scoringMatrix[i][j] != 0){
			
			// Diagonal move
			if(moveType == 0){
				alignedA.append(a[i-1]);
				alignedB.append(b[i-1]);
			
			// Horizontal
			}else if(moveType == 1){
				alignedA.append("-");
				alignedB.append(b[i-1]);
				
			// Vertical
			}else if(moveType == 2){
				alignedA.append(a[i-1]);
				alignedB.append("-");
			}
			
		}
		
	}
	
	public static int[][] findIndicesOfMaximums(int[][] scoringMatrix){
		
		// Initialise two arrays to store the i and j indices of the maximum values
		int[] iIndices = new int[0];
		int[] jIndices = new int[0];
		
		// Initialise a variable to record the max - values in scoring matrix can't be less than 1
		int max = -1;
		
		// Examine each score in the scoring matrix
		for(int i = 0; i < scoringMatrix.length; i++){
			for(int j = 0; j < scoringMatrix.length; j++){
				
				// Check if found new max
				if(scoringMatrix[i][j] > max){
					
					max = scoringMatrix[i][j];
					iIndices = new int[1];
					iIndices[0] = i;
					jIndices = new int[1];
					jIndices[0] = j;
					
				// Check if found new occurrence of current max
				}else if(scoringMatrix[i][j] == max){
					
					iIndices = ArrayMethods.append(iIndices, i);
					jIndices = ArrayMethods.append(jIndices, j);
				}
			}
		}
		
		int[][] output = {iIndices, jIndices};
		
		return output;
	}
	
	public static int[][] fillInScoringMatrix(int[][] scoringMatrix, char[] a, char[] b, int match, int misMatch, int gapPenalty){
		
		// Initialise a matrix to store the source (diagional, horizontal, vertical, or none) for each cell in scoring matrix
		int[][] sources = new int[scoringMatrix.length][scoringMatrix[0].length];
		
		// Initialise an array to store the scores of movements through the scoring matrix
		int[] scores = new int[4];
		int maxIndex;
		
		// Calculate the score for each cell in the scoring matrix
		for(int i = 1; i <= a.length; i++){
			
			for(int j = 1; j <= b.length; j++){
				
				// Reset the scoring array - note last value is zero - stops negative scores
				scores = new int[4];
				
				// Calculate the diagonal score
				scores[0] = scoringMatrix[i-1][j-1] + compareNucleotides(a[i-1], b[j-1], match, misMatch);
				
				// Calculate the horizontal score
				scores[1] = scoringMatrix[i][j-1] - gapPenalty;
				
				// Calculate the vertical score
				scores[2] = scoringMatrix[i-1][j] - gapPenalty;
				
				// Find the maximum index in the scores
				maxIndex = ArrayMethods.findMaxs(scores)[0];
				sources[i][j] = maxIndex;
				
				// Store the calculated score
				scoringMatrix[i][j] = scores[maxIndex];				
			}
		}
		
		return sources;
	}
	
	public static int score(char[] a, char[]b, int i, int j, int[][] scoringMatrix, int match, int misMatch, int gapPenalty){
		
		// Initialise an array to score the scores for each type of movement through the scoring matrix
		int[] scores = new int[4];
		
		// Calculate the diagonal score
		scores[0] = scoringMatrix[i-1][j-1] + compareNucleotides(a[i-1], b[j-1], match, misMatch);
		
		// Calculate the horizontal score
		scores[1] = scoringMatrix[i][j-1] - gapPenalty;
		
		// Calculate the vertical score
		scores[2] = scoringMatrix[i-1][j] - gapPenalty;
		
		// Choose the max score from diagonal, horizontal, and vertical - note 0 also included
		return ArrayMethods.max(scores);
	}
	
	public static int compareNucleotides(char a, char b, int match, int misMatch){
		
		int output = misMatch;
		if(a == b){
			output = match;
		}
		
		return output;
	}
	
	public static void printScoringMatrix(int[][] scoringMatrix, char[] a, char[] b){
		
		System.out.println("    " + ArrayMethods.toString(b, " "));
		for(int i = 0; i < scoringMatrix.length; i++){
			
			if(i != 0){
				System.out.print(a[i-1] + " ");
			}else{
				System.out.print("  ");
			}
			for(int j = 0; j < scoringMatrix[0].length; j++){
				
				System.out.print(scoringMatrix[i][j] + " ");
			}
			System.out.println();
		}		
	}

}
